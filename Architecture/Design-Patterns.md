<div align="center">

# ğŸ›ï¸ Design Patterns - Write Better Code! ğŸ›ï¸

![Patterns](https://img.shields.io/badge/Design_Patterns-Software_Architecture-blue?style=for-the-badge)
![SOLID](https://img.shields.io/badge/SOLID-Principles-green?style=for-the-badge)
![Clean](https://img.shields.io/badge/Clean_Code-Best_Practices-orange?style=for-the-badge)

### _Proven solutions to common problems_ ğŸ¯

**Master the patterns that power great software!** âœ¨

</div>

---

## ğŸ“š Table of Contents

- [ğŸ¯ What are Design Patterns](#-what-are-design-patterns)
- [ğŸ”¨ Creational Patterns](#-creational-patterns)
- [ğŸ—ï¸ Structural Patterns](#ï¸-structural-patterns)
- [âš¡ Behavioral Patterns](#-behavioral-patterns)
- [ğŸ¨ Modern Patterns](#-modern-patterns)
- [ğŸ’ SOLID Principles](#-solid-principles)
- [ğŸš« Anti-Patterns](#-anti-patterns)
- [ğŸ”— Pattern Combinations](#-pattern-combinations)
- [ğŸ’¡ Best Practices](#-best-practices)

---

<div align="center">

## ğŸ¯ What are Design Patterns

</div>

### Understanding Design Patterns ğŸŒŸ

```

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# DESIGN PATTERNS EXPLAINED

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ WHAT ARE DESIGN PATTERNS?                                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Design Patterns:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Reusable solutions to commonly occurring problems in software
design. Templates for solving problems that can be used in
many different situations.

Origin:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ "Gang of Four" (GoF) - 1994 book
â€¢ Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides
â€¢ 23 classic patterns
â€¢ Foundation of software design

Key Points:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Proven solutions
âœ… Language-independent
âœ… Reusable templates
âœ… Common vocabulary
âœ… Best practices
âœ… Avoid reinventing the wheel
âœ… Improve code quality
âœ… Easier maintenance

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ WHY USE DESIGN PATTERNS?                                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Benefits:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Code reusability
âœ… Better communication (common language)
âœ… Proven solutions
âœ… Easier maintenance
âœ… Flexibility and scalability
âœ… Faster development
âœ… Less bugs
âœ… Career advancement (understanding patterns)

Problems They Solve:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Tight coupling
â€¢ Code duplication
â€¢ Hard to extend
â€¢ Hard to test
â€¢ Difficult to understand
â€¢ Fragile code

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ PATTERN CATEGORIES                                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Three Main Categories:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Creational Patterns (5)
   â€¢ How objects are created
   â€¢ Singleton, Factory, Builder, Prototype, Abstract Factory

2. Structural Patterns (7)
   â€¢ How objects are composed
   â€¢ Adapter, Bridge, Composite, Decorator, Facade, Flyweight, Proxy

3. Behavioral Patterns (11)
   â€¢ How objects interact and communicate
   â€¢ Chain of Responsibility, Command, Iterator, Mediator,
   Memento, Observer, State, Strategy, Template Method,
   Visitor, Interpreter

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ WHEN TO USE PATTERNS                                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… DO Use Patterns When:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ The problem fits the pattern
â€¢ It simplifies the solution
â€¢ Team understands the pattern
â€¢ Long-term maintenance expected
â€¢ Code needs to be flexible

âŒ DON'T Use Patterns When:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Over-engineering simple problems
â€¢ Team doesn't understand patterns
â€¢ Forcing a pattern where it doesn't fit
â€¢ Adds unnecessary complexity
â€¢ Quick prototype/throwaway code

Remember:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"Patterns are tools, not rules.
Use them wisely, not religiously."

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ LEARNING PATH                                              â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Beginner Level:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Singleton
2. Factory Method
3. Observer
4. Strategy
5. Decorator

Intermediate Level:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 6. Builder 7. Adapter 8. Facade 9. Template Method 10. State

Advanced Level:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 11. Abstract Factory 12. Proxy 13. Composite 14. Chain of Responsibility 15. Command

Expert Level:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 16. Flyweight 17. Bridge 18. Mediator 19. Memento 20. Visitor 21. Interpreter 22. Prototype

Start simple, master gradually! ğŸ“ˆ

```

---

<div align="center">

## ğŸ”¨ Creational Patterns

</div>

### How Objects Are Created ğŸ—ï¸

```

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# CREATIONAL PATTERNS

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘ SINGLETON PATTERN                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Ensure a class has only ONE instance and provide a global
point of access to it.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Database connections
â€¢ Configuration managers
â€¢ Logging
â€¢ Cache
â€¢ Thread pools
â€¢ Device drivers

Pros:
âœ… Controlled access to sole instance
âœ… Global access point
âœ… Lazy initialization possible

Cons:
âŒ Global state (can be problematic)
âŒ Hard to test (tight coupling)
âŒ Thread-safety concerns
âŒ Violates Single Responsibility Principle

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

```

Singleton examples:

```javascript
// JavaScript - Modern (ES6+)
class Singleton {
  constructor() {
    if (Singleton.instance) {
      return Singleton.instance;
    }

    this.data = [];
    Singleton.instance = this;
  }

  addData(item) {
    this.data.push(item);
  }

  getData() {
    return this.data;
  }
}

// Usage
const instance1 = new Singleton();
const instance2 = new Singleton();
console.log(instance1 === instance2); // true

// JavaScript - Module Pattern (Better)
const Singleton = (() => {
  let instance;

  function init() {
    // Private variables and methods
    let data = [];

    return {
      // Public methods
      addData(item) {
        data.push(item);
      },
      getData() {
        return data;
      },
    };
  }

  return {
    getInstance() {
      if (!instance) {
        instance = init();
      }
      return instance;
    },
  };
})();

// Usage
const instance = Singleton.getInstance();
```

```python
# Python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance.data = []
        return cls._instance

    def add_data(self, item):
        self.data.append(item)

    def get_data(self):
        return self.data

# Usage
instance1 = Singleton()
instance2 = Singleton()
print(instance1 is instance2)  # True

# Python - Better with decorator
def singleton(cls):
    instances = {}

    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]

    return get_instance

@singleton
class Database:
    def __init__(self):
        self.connection = "Connected"

# Usage
db1 = Database()
db2 = Database()
print(db1 is db2)  # True
```

```java
// Java - Thread-safe (Bill Pugh)
public class Singleton {
    private Singleton() {}

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}

// Java - Enum (Best)
public enum Singleton {
    INSTANCE;

    public void doSomething() {
        // Your code here
    }
}

// Usage
Singleton.INSTANCE.doSomething();
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   FACTORY PATTERN                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Create objects without specifying the exact class to create.
Defines an interface for creating an object, but lets
subclasses decide which class to instantiate.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Creation logic is complex
â€¢ Don't know exact types beforehand
â€¢ Want to centralize object creation
â€¢ Need to decouple object creation

Pros:
âœ… Loose coupling
âœ… Single Responsibility (creation separate)
âœ… Open/Closed Principle (easy to extend)

Cons:
âŒ Can become complex
âŒ More classes to manage

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Factory examples:

```javascript
// JavaScript
class Dog {
  speak() {
    return "Woof!";
  }
}

class Cat {
  speak() {
    return "Meow!";
  }
}

class Bird {
  speak() {
    return "Tweet!";
  }
}

// Factory
class AnimalFactory {
  createAnimal(type) {
    switch (type) {
      case "dog":
        return new Dog();
      case "cat":
        return new Cat();
      case "bird":
        return new Bird();
      default:
        throw new Error("Invalid animal type");
    }
  }
}

// Usage
const factory = new AnimalFactory();
const dog = factory.createAnimal("dog");
console.log(dog.speak()); // "Woof!"

// Modern approach with Map
class AnimalFactory2 {
  constructor() {
    this.animals = {
      dog: Dog,
      cat: Cat,
      bird: Bird,
    };
  }

  createAnimal(type) {
    const AnimalClass = this.animals[type];
    if (!AnimalClass) {
      throw new Error("Invalid animal type");
    }
    return new AnimalClass();
  }
}
```

```python
# Python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

class AnimalFactory:
    def create_animal(self, animal_type):
        if animal_type == 'dog':
            return Dog()
        elif animal_type == 'cat':
            return Cat()
        else:
            raise ValueError('Invalid animal type')

# Usage
factory = AnimalFactory()
dog = factory.create_animal('dog')
print(dog.speak())  # "Woof!"

# Python - Better with dictionary
class AnimalFactory2:
    def __init__(self):
        self._animals = {
            'dog': Dog,
            'cat': Cat
        }

    def create_animal(self, animal_type):
        animal_class = self._animals.get(animal_type)
        if not animal_class:
            raise ValueError('Invalid animal type')
        return animal_class()
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   BUILDER PATTERN                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Separate the construction of a complex object from its
representation. Build objects step by step.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Object has many parameters (telescoping constructor)
â€¢ Want immutable objects
â€¢ Step-by-step construction needed
â€¢ Different representations of same object

Pros:
âœ… Readable code (fluent interface)
âœ… Can create different representations
âœ… Immutable objects
âœ… Single Responsibility

Cons:
âŒ More code/classes
âŒ Overhead for simple objects

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Builder examples:

```javascript
// JavaScript
class User {
  constructor(builder) {
    this.name = builder.name;
    this.age = builder.age;
    this.email = builder.email;
    this.phone = builder.phone;
    this.address = builder.address;
  }
}

class UserBuilder {
  constructor(name) {
    this.name = name;
  }

  setAge(age) {
    this.age = age;
    return this; // Return this for chaining
  }

  setEmail(email) {
    this.email = email;
    return this;
  }

  setPhone(phone) {
    this.phone = phone;
    return this;
  }

  setAddress(address) {
    this.address = address;
    return this;
  }

  build() {
    return new User(this);
  }
}

// Usage
const user = new UserBuilder("John Doe")
  .setAge(30)
  .setEmail("john@example.com")
  .setPhone("123-456-7890")
  .setAddress("123 Main St")
  .build();

console.log(user);
```

```python
# Python
class User:
    def __init__(self, builder):
        self.name = builder.name
        self.age = builder.age
        self.email = builder.email
        self.phone = builder.phone

class UserBuilder:
    def __init__(self, name):
        self.name = name
        self.age = None
        self.email = None
        self.phone = None

    def set_age(self, age):
        self.age = age
        return self

    def set_email(self, email):
        self.email = email
        return self

    def set_phone(self, phone):
        self.phone = phone
        return self

    def build(self):
        return User(self)

# Usage
user = (UserBuilder('John Doe')
    .set_age(30)
    .set_email('john@example.com')
    .set_phone('123-456-7890')
    .build())
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   PROTOTYPE PATTERN                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Create new objects by copying existing objects (prototypes).

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Object creation is expensive
â€¢ Want to avoid subclasses
â€¢ Need to hide creation complexity

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Prototype example:

```javascript
// JavaScript (has built-in prototype)
class Shape {
  constructor() {
    this.type = "";
  }

  clone() {
    return Object.create(this);
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.type = "Circle";
    this.radius = radius;
  }

  clone() {
    return new Circle(this.radius);
  }
}

// Usage
const circle1 = new Circle(10);
const circle2 = circle1.clone();
console.log(circle2.radius); // 10
```

```python
# Python
import copy

class Prototype:
    def clone(self):
        return copy.deepcopy(self)

class Circle(Prototype):
    def __init__(self, radius):
        self.radius = radius

    def __str__(self):
        return f"Circle(radius={self.radius})"

# Usage
circle1 = Circle(10)
circle2 = circle1.clone()
print(circle2)  # Circle(radius=10)
```

---

<div align="center">

## ğŸ—ï¸ Structural Patterns

</div>

### How Objects Are Composed ğŸ§±

```
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STRUCTURAL PATTERNS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   ADAPTER PATTERN                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Convert the interface of a class into another interface that
clients expect. Makes incompatible interfaces work together.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Legacy code integration
â€¢ Third-party libraries
â€¢ Incompatible interfaces
â€¢ Want to use existing class

Analogy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Like a power adapter for different countries.
US plug â†’ Adapter â†’ EU socket

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Adapter examples:

```javascript
// JavaScript
// Old interface
class OldLogger {
  logMessage(message) {
    console.log(`OLD: ${message}`);
  }
}

// New interface expected
class NewLogger {
  log(message, level) {
    console.log(`[${level}] ${message}`);
  }
}

// Adapter
class LoggerAdapter {
  constructor(oldLogger) {
    this.oldLogger = oldLogger;
  }

  log(message, level = "INFO") {
    // Adapt old interface to new
    this.oldLogger.logMessage(`[${level}] ${message}`);
  }
}

// Usage
const oldLogger = new OldLogger();
const adapter = new LoggerAdapter(oldLogger);
adapter.log("Hello", "INFO"); // OLD: [INFO] Hello

// Real-world example: Payment adapters
class PayPalPayment {
  makePayment(amount) {
    console.log(`PayPal payment of $${amount}`);
  }
}

class StripePayment {
  processPayment(amount, currency) {
    console.log(`Stripe payment of ${amount} ${currency}`);
  }
}

// Adapter for Stripe
class StripeAdapter {
  constructor(stripe) {
    this.stripe = stripe;
  }

  makePayment(amount) {
    this.stripe.processPayment(amount, "USD");
  }
}

// Usage
function processPayment(paymentMethod, amount) {
  paymentMethod.makePayment(amount);
}

const paypal = new PayPalPayment();
const stripe = new StripeAdapter(new StripePayment());

processPayment(paypal, 100);
processPayment(stripe, 200);
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   DECORATOR PATTERN                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Attach additional responsibilities to an object dynamically.
Flexible alternative to subclassing.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Add features dynamically
â€¢ Combine multiple features
â€¢ Avoid subclass explosion
â€¢ Single Responsibility

Analogy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Like adding toppings to pizza or accessories to a car.

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Decorator examples:

```javascript
// JavaScript
// Base component
class Coffee {
  cost() {
    return 5;
  }

  description() {
    return "Coffee";
  }
}

// Decorators
class MilkDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }

  cost() {
    return this.coffee.cost() + 1;
  }

  description() {
    return this.coffee.description() + ", Milk";
  }
}

class SugarDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }

  cost() {
    return this.coffee.cost() + 0.5;
  }

  description() {
    return this.coffee.description() + ", Sugar";
  }
}

class WhipDecorator {
  constructor(coffee) {
    this.coffee = coffee;
  }

  cost() {
    return this.coffee.cost() + 2;
  }

  description() {
    return this.coffee.description() + ", Whipped Cream";
  }
}

// Usage
let coffee = new Coffee();
console.log(coffee.description(), "$" + coffee.cost());
// Coffee $5

coffee = new MilkDecorator(coffee);
console.log(coffee.description(), "$" + coffee.cost());
// Coffee, Milk $6

coffee = new SugarDecorator(coffee);
console.log(coffee.description(), "$" + coffee.cost());
// Coffee, Milk, Sugar $6.5

coffee = new WhipDecorator(coffee);
console.log(coffee.description(), "$" + coffee.cost());
// Coffee, Milk, Sugar, Whipped Cream $8.5
```

```python
# Python - Using decorators (language feature)
def uppercase_decorator(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result.upper()
    return wrapper

def exclamation_decorator(func):
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        return result + '!!!'
    return wrapper

@exclamation_decorator
@uppercase_decorator
def greet(name):
    return f'hello {name}'

print(greet('world'))  # HELLO WORLD!!!
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   FACADE PATTERN                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Provide a simplified interface to a complex subsystem.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Complex system with many classes
â€¢ Want simple interface
â€¢ Decouple subsystem from clients
â€¢ Layer architecture

Analogy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Like a restaurant waiter - you don't interact with kitchen,
chef, dishwasher directly. Waiter is the facade.

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Facade example:

```javascript
// JavaScript
// Complex subsystem
class CPU {
  freeze() {
    console.log("CPU: Freeze");
  }

  jump(address) {
    console.log(`CPU: Jump to ${address}`);
  }

  execute() {
    console.log("CPU: Execute");
  }
}

class Memory {
  load(address, data) {
    console.log(`Memory: Load ${data} at ${address}`);
  }
}

class HardDrive {
  read(sector, size) {
    console.log(`HardDrive: Read ${size} bytes from sector ${sector}`);
    return "data";
  }
}

// Facade
class ComputerFacade {
  constructor() {
    this.cpu = new CPU();
    this.memory = new Memory();
    this.hardDrive = new HardDrive();
  }

  start() {
    console.log("Starting computer...");
    this.cpu.freeze();
    const data = this.hardDrive.read(0, 1024);
    this.memory.load(0, data);
    this.cpu.jump(0);
    this.cpu.execute();
    console.log("Computer started!");
  }
}

// Usage - Simple interface!
const computer = new ComputerFacade();
computer.start();
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   PROXY PATTERN                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Provide a surrogate or placeholder for another object to
control access to it.

Types:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Virtual Proxy: Lazy initialization
â€¢ Protection Proxy: Access control
â€¢ Remote Proxy: Remote object representation
â€¢ Caching Proxy: Cache results

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Expensive object creation (lazy loading)
â€¢ Access control needed
â€¢ Logging/monitoring
â€¢ Caching

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Proxy example:

```javascript
// JavaScript
// Real object
class Image {
  constructor(filename) {
    this.filename = filename;
    this.load();
  }

  load() {
    console.log(`Loading image: ${this.filename}`);
  }

  display() {
    console.log(`Displaying image: ${this.filename}`);
  }
}

// Proxy with lazy loading
class ImageProxy {
  constructor(filename) {
    this.filename = filename;
    this.image = null;
  }

  display() {
    if (!this.image) {
      this.image = new Image(this.filename);
    }
    this.image.display();
  }
}

// Usage
const image = new ImageProxy("photo.jpg");
// Image not loaded yet!

image.display(); // Loads and displays
// Loading image: photo.jpg
// Displaying image: photo.jpg

image.display(); // Just displays (already loaded)
// Displaying image: photo.jpg

// Modern JavaScript Proxy
const target = {
  message: "Hello",
};

const handler = {
  get(target, prop) {
    console.log(`Accessing property: ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`Setting ${prop} to ${value}`);
    target[prop] = value;
    return true;
  },
};

const proxy = new Proxy(target, handler);
console.log(proxy.message); // Logs access then returns value
proxy.message = "World"; // Logs setting
```

---

<div align="center">

## âš¡ Behavioral Patterns

</div>

### How Objects Interact ğŸ¤

```
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BEHAVIORAL PATTERNS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   OBSERVER PATTERN                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Define a one-to-many dependency between objects so that when
one object changes state, all its dependents are notified.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Event handling
â€¢ Real-time updates
â€¢ Decoupled communication
â€¢ Pub/Sub systems

Analogy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Like subscribing to a YouTube channel - you get notified
when new videos are uploaded.

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Observer examples:

```javascript
// JavaScript
class Subject {
  constructor() {
    this.observers = [];
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  unsubscribe(observer) {
    this.observers = this.observers.filter((obs) => obs !== observer);
  }

  notify(data) {
    this.observers.forEach((observer) => observer.update(data));
  }
}

class Observer {
  constructor(name) {
    this.name = name;
  }

  update(data) {
    console.log(`${this.name} received: ${data}`);
  }
}

// Usage
const subject = new Subject();

const observer1 = new Observer("Observer 1");
const observer2 = new Observer("Observer 2");

subject.subscribe(observer1);
subject.subscribe(observer2);

subject.notify("Hello!");
// Observer 1 received: Hello!
// Observer 2 received: Hello!

subject.unsubscribe(observer1);
subject.notify("Goodbye!");
// Observer 2 received: Goodbye!

// Real-world: Event Emitter
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
  }

  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach((listener) => listener(data));
    }
  }

  off(event, listenerToRemove) {
    if (this.events[event]) {
      this.events[event] = this.events[event].filter(
        (listener) => listener !== listenerToRemove
      );
    }
  }
}

// Usage
const emitter = new EventEmitter();

const handleUserLogin = (data) => {
  console.log(`User logged in: ${data.username}`);
};

emitter.on("userLogin", handleUserLogin);
emitter.on("userLogin", (data) => {
  console.log(`Send welcome email to ${data.email}`);
});

emitter.emit("userLogin", {
  username: "john",
  email: "john@example.com",
});
// User logged in: john
// Send welcome email to john@example.com
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   STRATEGY PATTERN                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Define a family of algorithms, encapsulate each one, and make
them interchangeable. Let the algorithm vary independently.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Multiple algorithms for same task
â€¢ Want to switch algorithms at runtime
â€¢ Avoid conditional statements
â€¢ Encapsulate algorithms

Analogy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Like choosing different routes to reach a destination:
highway, scenic route, shortest path.

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Strategy examples:

```javascript
// JavaScript
// Strategies
class CreditCardStrategy {
  pay(amount) {
    console.log(`Paid $${amount} with Credit Card`);
  }
}

class PayPalStrategy {
  pay(amount) {
    console.log(`Paid $${amount} with PayPal`);
  }
}

class CryptoStrategy {
  pay(amount) {
    console.log(`Paid $${amount} with Cryptocurrency`);
  }
}

// Context
class ShoppingCart {
  constructor(paymentStrategy) {
    this.paymentStrategy = paymentStrategy;
  }

  setPaymentStrategy(strategy) {
    this.paymentStrategy = strategy;
  }

  checkout(amount) {
    this.paymentStrategy.pay(amount);
  }
}

// Usage
const cart = new ShoppingCart(new CreditCardStrategy());
cart.checkout(100); // Paid $100 with Credit Card

cart.setPaymentStrategy(new PayPalStrategy());
cart.checkout(200); // Paid $200 with PayPal

cart.setPaymentStrategy(new CryptoStrategy());
cart.checkout(300); // Paid $300 with Cryptocurrency

// Real-world: Sorting strategies
class BubbleSort {
  sort(array) {
    console.log("Sorting with Bubble Sort");
    // Implementation...
    return array.sort((a, b) => a - b);
  }
}

class QuickSort {
  sort(array) {
    console.log("Sorting with Quick Sort");
    // Implementation...
    return array.sort((a, b) => a - b);
  }
}

class Sorter {
  constructor(strategy) {
    this.strategy = strategy;
  }

  sort(array) {
    return this.strategy.sort(array);
  }
}

// Usage
const sorter = new Sorter(new QuickSort());
console.log(sorter.sort([5, 2, 8, 1, 9]));
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   COMMAND PATTERN                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Encapsulate a request as an object, allowing you to
parameterize clients with different requests, queue requests,
and support undoable operations.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Undo/Redo functionality
â€¢ Transaction systems
â€¢ Queue operations
â€¢ Macro recording

Analogy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Like a restaurant order - waiter takes order (command),
gives to chef, order can be modified or cancelled.

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Command example:

```javascript
// JavaScript
// Receiver
class Light {
  on() {
    console.log("Light is ON");
  }

  off() {
    console.log("Light is OFF");
  }
}

// Commands
class LightOnCommand {
  constructor(light) {
    this.light = light;
  }

  execute() {
    this.light.on();
  }

  undo() {
    this.light.off();
  }
}

class LightOffCommand {
  constructor(light) {
    this.light = light;
  }

  execute() {
    this.light.off();
  }

  undo() {
    this.light.on();
  }
}

// Invoker
class RemoteControl {
  constructor() {
    this.history = [];
  }

  execute(command) {
    command.execute();
    this.history.push(command);
  }

  undo() {
    const command = this.history.pop();
    if (command) {
      command.undo();
    }
  }
}

// Usage
const light = new Light();
const lightOn = new LightOnCommand(light);
const lightOff = new LightOffCommand(light);

const remote = new RemoteControl();

remote.execute(lightOn); // Light is ON
remote.execute(lightOff); // Light is OFF
remote.undo(); // Light is ON
remote.undo(); // Light is OFF
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   STATE PATTERN                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Allow an object to alter its behavior when its internal
state changes. The object will appear to change its class.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Object behavior depends on state
â€¢ Large conditional statements based on state
â€¢ State-specific behavior

Analogy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Like a vending machine - different behaviors based on
current state (HasMoney, NoMoney, Dispensing).

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

State example:

```javascript
// JavaScript
// States
class OrderedState {
  next(order) {
    order.setState(order.shippedState);
  }

  getStatus() {
    return "Ordered";
  }
}

class ShippedState {
  next(order) {
    order.setState(order.deliveredState);
  }

  getStatus() {
    return "Shipped";
  }
}

class DeliveredState {
  next(order) {
    console.log("Order already delivered");
  }

  getStatus() {
    return "Delivered";
  }
}

// Context
class Order {
  constructor() {
    this.orderedState = new OrderedState();
    this.shippedState = new ShippedState();
    this.deliveredState = new DeliveredState();

    this.currentState = this.orderedState;
  }

  setState(state) {
    this.currentState = state;
  }

  next() {
    this.currentState.next(this);
  }

  getStatus() {
    return this.currentState.getStatus();
  }
}

// Usage
const order = new Order();
console.log(order.getStatus()); // Ordered

order.next();
console.log(order.getStatus()); // Shipped

order.next();
console.log(order.getStatus()); // Delivered

order.next(); // Order already delivered
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   TEMPLATE METHOD PATTERN                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Define the skeleton of an algorithm in a method, deferring
some steps to subclasses. Let subclasses redefine certain
steps without changing the algorithm's structure.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Common algorithm with varying implementations
â€¢ Control extension points
â€¢ Avoid code duplication
â€¢ Framework design

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Template Method example:

```javascript
// JavaScript
class DataProcessor {
  // Template method
  process() {
    this.readData();
    this.processData();
    this.saveData();
  }

  readData() {
    throw new Error("readData must be implemented");
  }

  processData() {
    throw new Error("processData must be implemented");
  }

  saveData() {
    console.log("Saving data...");
  }
}

class CSVProcessor extends DataProcessor {
  readData() {
    console.log("Reading CSV file");
  }

  processData() {
    console.log("Processing CSV data");
  }
}

class JSONProcessor extends DataProcessor {
  readData() {
    console.log("Reading JSON file");
  }

  processData() {
    console.log("Processing JSON data");
  }
}

// Usage
const csvProcessor = new CSVProcessor();
csvProcessor.process();
// Reading CSV file
// Processing CSV data
// Saving data...

const jsonProcessor = new JSONProcessor();
jsonProcessor.process();
// Reading JSON file
// Processing JSON data
// Saving data...
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   CHAIN OF RESPONSIBILITY                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Pass requests along a chain of handlers. Each handler decides
either to process the request or pass it to the next handler.

When to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â€¢ Multiple objects can handle request
â€¢ Handler not known in advance
â€¢ Middleware systems
â€¢ Event bubbling

Analogy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Like customer support - Level 1 â†’ Level 2 â†’ Manager
Each level tries to solve, or passes to next.

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Chain of Responsibility example:

```javascript
// JavaScript
class Handler {
  constructor() {
    this.nextHandler = null;
  }

  setNext(handler) {
    this.nextHandler = handler;
    return handler; // For chaining
  }

  handle(request) {
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    return null;
  }
}

class Level1Support extends Handler {
  handle(request) {
    if (request.priority === "low") {
      console.log("Level 1: Handling low priority request");
      return true;
    }
    console.log("Level 1: Passing to next level");
    return super.handle(request);
  }
}

class Level2Support extends Handler {
  handle(request) {
    if (request.priority === "medium") {
      console.log("Level 2: Handling medium priority request");
      return true;
    }
    console.log("Level 2: Passing to next level");
    return super.handle(request);
  }
}

class ManagerSupport extends Handler {
  handle(request) {
    console.log("Manager: Handling high priority request");
    return true;
  }
}

// Setup chain
const level1 = new Level1Support();
const level2 = new Level2Support();
const manager = new ManagerSupport();

level1.setNext(level2).setNext(manager);

// Usage
level1.handle({ priority: "low" });
// Level 1: Handling low priority request

level1.handle({ priority: "medium" });
// Level 1: Passing to next level
// Level 2: Handling medium priority request

level1.handle({ priority: "high" });
// Level 1: Passing to next level
// Level 2: Passing to next level
// Manager: Handling high priority request

// Real-world: Express middleware
class Middleware {
  constructor() {
    this.middlewares = [];
  }

  use(fn) {
    this.middlewares.push(fn);
  }

  execute(context) {
    let index = 0;

    const next = () => {
      if (index < this.middlewares.length) {
        const middleware = this.middlewares[index++];
        middleware(context, next);
      }
    };

    next();
  }
}

// Usage
const app = new Middleware();

app.use((context, next) => {
  console.log("Logging middleware");
  next();
});

app.use((context, next) => {
  console.log("Auth middleware");
  if (context.authenticated) {
    next();
  } else {
    console.log("Not authenticated");
  }
});

app.use((context, next) => {
  console.log("Final handler");
});

app.execute({ authenticated: true });
// Logging middleware
// Auth middleware
// Final handler
```

---

<div align="center">

## ğŸ¨ Modern Patterns

</div>

### Contemporary Design Patterns ğŸš€

```
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MODERN PATTERNS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   DEPENDENCY INJECTION                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Provide dependencies from the outside rather than creating
them internally. Inversion of Control (IoC).

Benefits:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Loose coupling
âœ… Easy testing (mock dependencies)
âœ… Flexibility
âœ… Single Responsibility

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Dependency Injection examples:

```javascript
// JavaScript

// âŒ BAD - Tight coupling
class UserService {
  constructor() {
    this.database = new Database(); // Hard-coded dependency
  }

  getUser(id) {
    return this.database.query(`SELECT * FROM users WHERE id = ${id}`);
  }
}

// âœ… GOOD - Dependency Injection
class UserService {
  constructor(database) {
    this.database = database; // Injected dependency
  }

  getUser(id) {
    return this.database.query(`SELECT * FROM users WHERE id = ${id}`);
  }
}

// Usage
const database = new Database();
const userService = new UserService(database);

// Easy to mock for testing
const mockDatabase = {
  query: (sql) => ({ id: 1, name: "Test User" }),
};
const testUserService = new UserService(mockDatabase);

// Constructor Injection (shown above)
// Property Injection
class UserService2 {
  setDatabase(database) {
    this.database = database;
  }

  getUser(id) {
    return this.database.query(`SELECT * FROM users WHERE id = ${id}`);
  }
}

const service = new UserService2();
service.setDatabase(new Database());

// Method Injection
class UserService3 {
  getUser(id, database) {
    return database.query(`SELECT * FROM users WHERE id = ${id}`);
  }
}

const service3 = new UserService3();
service3.getUser(1, new Database());
```

```typescript
// TypeScript with interfaces
interface IDatabase {
  query(sql: string): any;
}

interface ILogger {
  log(message: string): void;
}

class UserService {
  constructor(private database: IDatabase, private logger: ILogger) {}

  async getUser(id: number) {
    this.logger.log(`Fetching user ${id}`);
    return this.database.query(`SELECT * FROM users WHERE id = ${id}`);
  }
}

// Different implementations
class MySQLDatabase implements IDatabase {
  query(sql: string) {
    console.log("MySQL query:", sql);
    return { id: 1, name: "John" };
  }
}

class PostgresDatabase implements IDatabase {
  query(sql: string) {
    console.log("Postgres query:", sql);
    return { id: 1, name: "John" };
  }
}

class ConsoleLogger implements ILogger {
  log(message: string) {
    console.log(message);
  }
}

// Usage - Easy to swap implementations
const mysqlService = new UserService(new MySQLDatabase(), new ConsoleLogger());
const postgresService = new UserService(
  new PostgresDatabase(),
  new ConsoleLogger()
);
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   REPOSITORY PATTERN                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Separate data access logic from business logic. Mediates
between domain and data mapping layers.

Benefits:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Centralized data access
âœ… Easy to test
âœ… Swap data sources
âœ… Single Responsibility

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Repository pattern:

```javascript
// JavaScript
class UserRepository {
  constructor(database) {
    this.database = database;
  }

  async findById(id) {
    return this.database.query("SELECT * FROM users WHERE id = ?", [id]);
  }

  async findByEmail(email) {
    return this.database.query("SELECT * FROM users WHERE email = ?", [email]);
  }

  async findAll() {
    return this.database.query("SELECT * FROM users");
  }

  async create(user) {
    return this.database.query(
      "INSERT INTO users (name, email) VALUES (?, ?)",
      [user.name, user.email]
    );
  }

  async update(id, user) {
    return this.database.query(
      "UPDATE users SET name = ?, email = ? WHERE id = ?",
      [user.name, user.email, id]
    );
  }

  async delete(id) {
    return this.database.query("DELETE FROM users WHERE id = ?", [id]);
  }
}

// Service layer uses repository
class UserService {
  constructor(userRepository) {
    this.userRepository = userRepository;
  }

  async getUser(id) {
    return this.userRepository.findById(id);
  }

  async createUser(userData) {
    // Business logic
    if (!userData.email.includes("@")) {
      throw new Error("Invalid email");
    }

    // Use repository
    return this.userRepository.create(userData);
  }
}

// Usage
const database = new Database();
const userRepository = new UserRepository(database);
const userService = new UserService(userRepository);

await userService.createUser({ name: "John", email: "john@example.com" });
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   MODULE PATTERN                           â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Encapsulate private and public members. JavaScript-specific.

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Module pattern:

```javascript
// JavaScript - IIFE (Immediately Invoked Function Expression)
const UserModule = (function () {
  // Private variables
  let users = [];
  let nextId = 1;

  // Private methods
  function validateUser(user) {
    return user.name && user.email;
  }

  // Public API
  return {
    addUser(user) {
      if (!validateUser(user)) {
        throw new Error("Invalid user");
      }
      user.id = nextId++;
      users.push(user);
      return user;
    },

    getUser(id) {
      return users.find((u) => u.id === id);
    },

    getAllUsers() {
      return [...users]; // Return copy
    },

    removeUser(id) {
      users = users.filter((u) => u.id !== id);
    },
  };
})();

// Usage
UserModule.addUser({ name: "John", email: "john@example.com" });
console.log(UserModule.getAllUsers());

// Can't access private variables
console.log(UserModule.users); // undefined

// ES6 Modules (better approach)
// user-module.js
let users = [];
let nextId = 1;

function validateUser(user) {
  return user.name && user.email;
}

export function addUser(user) {
  if (!validateUser(user)) {
    throw new Error("Invalid user");
  }
  user.id = nextId++;
  users.push(user);
  return user;
}

export function getUser(id) {
  return users.find((u) => u.id === id);
}

// Import in another file
// import { addUser, getUser } from './user-module.js';
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   FLUX/REDUX PATTERN                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Purpose:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Unidirectional data flow for state management.
Popular in React applications.

Flow:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Action â†’ Dispatcher â†’ Store â†’ View
         â†‘                      |
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Implementation:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Redux pattern:

```javascript
// JavaScript - Simple Redux implementation
class Store {
  constructor(reducer, initialState = {}) {
    this.reducer = reducer;
    this.state = initialState;
    this.listeners = [];
  }

  getState() {
    return this.state;
  }

  dispatch(action) {
    this.state = this.reducer(this.state, action);
    this.listeners.forEach((listener) => listener());
  }

  subscribe(listener) {
    this.listeners.push(listener);

    // Return unsubscribe function
    return () => {
      this.listeners = this.listeners.filter((l) => l !== listener);
    };
  }
}

// Reducer
function counterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case "INCREMENT":
      return { count: state.count + 1 };
    case "DECREMENT":
      return { count: state.count - 1 };
    case "ADD":
      return { count: state.count + action.payload };
    default:
      return state;
  }
}

// Usage
const store = new Store(counterReducer, { count: 0 });

store.subscribe(() => {
  console.log("State changed:", store.getState());
});

store.dispatch({ type: "INCREMENT" });
// State changed: { count: 1 }

store.dispatch({ type: "INCREMENT" });
// State changed: { count: 2 }

store.dispatch({ type: "ADD", payload: 5 });
// State changed: { count: 7 }

store.dispatch({ type: "DECREMENT" });
// State changed: { count: 6 }
```

---

<div align="center">

## ğŸ’ SOLID Principles

</div>

### Five Principles of OOP ğŸ¯

```
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SOLID PRINCIPLES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   S - SINGLE RESPONSIBILITY                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Principle:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
A class should have only ONE reason to change.
Do one thing and do it well.

Why Important:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Easier to understand
âœ… Easier to test
âœ… Less coupled
âœ… Easier to maintain

Examples:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Single Responsibility examples:

```javascript
// âŒ BAD - Multiple responsibilities
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  // User data management
  getName() {
    return this.name;
  }

  // Database operations
  save() {
    console.log("Saving to database...");
  }

  // Email operations
  sendWelcomeEmail() {
    console.log("Sending welcome email...");
  }

  // Validation
  validateEmail() {
    return this.email.includes("@");
  }
}

// âœ… GOOD - Single responsibility
class User {
  constructor(name, email) {
    this.name = name;
    this.email = email;
  }

  getName() {
    return this.name;
  }

  getEmail() {
    return this.email;
  }
}

class UserRepository {
  save(user) {
    console.log(`Saving ${user.getName()} to database...`);
  }

  findById(id) {
    // Database logic
  }
}

class EmailService {
  sendWelcomeEmail(user) {
    console.log(`Sending welcome email to ${user.getEmail()}...`);
  }
}

class UserValidator {
  validateEmail(email) {
    return email.includes("@");
  }

  validateName(name) {
    return name.length > 0;
  }
}

// Usage
const user = new User("John", "john@example.com");
const repository = new UserRepository();
const emailService = new EmailService();
const validator = new UserValidator();

if (validator.validateEmail(user.getEmail())) {
  repository.save(user);
  emailService.sendWelcomeEmail(user);
}
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   O - OPEN/CLOSED PRINCIPLE                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Principle:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Open for extension, closed for modification.
Add new functionality without changing existing code.

Why Important:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Prevent breaking existing code
âœ… Easy to extend
âœ… Stable codebase

Examples:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Open/Closed examples:

```javascript
// âŒ BAD - Need to modify class for new shapes
class AreaCalculator {
  calculate(shapes) {
    let totalArea = 0;

    for (const shape of shapes) {
      if (shape.type === "circle") {
        totalArea += Math.PI * shape.radius ** 2;
      } else if (shape.type === "rectangle") {
        totalArea += shape.width * shape.height;
      }
      // Need to modify this class to add new shapes!
    }

    return totalArea;
  }
}

// âœ… GOOD - Open for extension, closed for modification
class Shape {
  area() {
    throw new Error("area() must be implemented");
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  area() {
    return Math.PI * this.radius ** 2;
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}

class Triangle extends Shape {
  constructor(base, height) {
    super();
    this.base = base;
    this.height = height;
  }

  area() {
    return (this.base * this.height) / 2;
  }
}

class AreaCalculator {
  calculate(shapes) {
    return shapes.reduce((total, shape) => total + shape.area(), 0);
  }
}

// Usage - Can add new shapes without modifying AreaCalculator!
const shapes = [new Circle(5), new Rectangle(4, 6), new Triangle(3, 4)];

const calculator = new AreaCalculator();
console.log(calculator.calculate(shapes));
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   L - LISKOV SUBSTITUTION                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Principle:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Objects of a superclass should be replaceable with objects
of its subclasses without breaking the application.

Why Important:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Proper inheritance
âœ… Polymorphism works correctly
âœ… Predictable behavior

Examples:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Liskov Substitution examples:

```javascript
// âŒ BAD - Square violates LSP
class Rectangle {
  constructor(width, height) {
    this.width = width;
    this.height = height;
  }

  setWidth(width) {
    this.width = width;
  }

  setHeight(height) {
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}

class Square extends Rectangle {
  setWidth(width) {
    this.width = width;
    this.height = width; // Problem!
  }

  setHeight(height) {
    this.width = height; // Problem!
    this.height = height;
  }
}

// This breaks when using Square
function testRectangle(rectangle) {
  rectangle.setWidth(5);
  rectangle.setHeight(4);
  console.log(rectangle.area()); // Expected: 20
}

testRectangle(new Rectangle(0, 0)); // 20 âœ“
testRectangle(new Square(0, 0)); // 16 âœ— (Square changed both dimensions!)

// âœ… GOOD - Proper abstraction
class Shape {
  area() {
    throw new Error("area() must be implemented");
  }
}

class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  area() {
    return this.width * this.height;
  }
}

class Square extends Shape {
  constructor(side) {
    super();
    this.side = side;
  }

  area() {
    return this.side ** 2;
  }
}

// Now both work correctly in their own way
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   I - INTERFACE SEGREGATION                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Principle:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Clients should not be forced to depend on interfaces they
don't use. Many specific interfaces are better than one
general-purpose interface.

Why Important:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Smaller, focused interfaces
âœ… Less coupling
âœ… Easier to implement

Examples:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Interface Segregation examples:

```typescript
// TypeScript

// âŒ BAD - Fat interface
interface Worker {
  work(): void;
  eat(): void;
  sleep(): void;
}

class HumanWorker implements Worker {
  work() {
    console.log("Working...");
  }

  eat() {
    console.log("Eating...");
  }

  sleep() {
    console.log("Sleeping...");
  }
}

class RobotWorker implements Worker {
  work() {
    console.log("Working...");
  }

  eat() {
    // Robots don't eat! Forced to implement
    throw new Error("Robots don't eat");
  }

  sleep() {
    // Robots don't sleep! Forced to implement
    throw new Error("Robots don't sleep");
  }
}

// âœ… GOOD - Segregated interfaces
interface Workable {
  work(): void;
}

interface Eatable {
  eat(): void;
}

interface Sleepable {
  sleep(): void;
}

class HumanWorker implements Workable, Eatable, Sleepable {
  work() {
    console.log("Working...");
  }

  eat() {
    console.log("Eating...");
  }

  sleep() {
    console.log("Sleeping...");
  }
}

class RobotWorker implements Workable {
  work() {
    console.log("Working...");
  }
  // Only implements what it needs!
}
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   D - DEPENDENCY INVERSION                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Principle:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
High-level modules should not depend on low-level modules.
Both should depend on abstractions.
Abstractions should not depend on details.

Why Important:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Loose coupling
âœ… Easy to test
âœ… Flexible
âœ… Easy to swap implementations

Examples:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

Dependency Inversion examples:

```typescript
// TypeScript

// âŒ BAD - High-level depends on low-level
class MySQLDatabase {
  save(data: string) {
    console.log(`Saving to MySQL: ${data}`);
  }
}

class UserService {
  private database: MySQLDatabase;

  constructor() {
    this.database = new MySQLDatabase(); // Tight coupling!
  }

  saveUser(user: string) {
    this.database.save(user);
  }
}

// Can't easily switch to PostgreSQL or MongoDB!

// âœ… GOOD - Both depend on abstraction
interface IDatabase {
  save(data: string): void;
}

class MySQLDatabase implements IDatabase {
  save(data: string) {
    console.log(`Saving to MySQL: ${data}`);
  }
}

class PostgreSQLDatabase implements IDatabase {
  save(data: string) {
    console.log(`Saving to PostgreSQL: ${data}`);
  }
}

class MongoDBDatabase implements IDatabase {
  save(data: string) {
    console.log(`Saving to MongoDB: ${data}`);
  }
}

class UserService {
  constructor(private database: IDatabase) {}

  saveUser(user: string) {
    this.database.save(user);
  }
}

// Usage - Easy to swap implementations!
const mysqlService = new UserService(new MySQLDatabase());
const postgresService = new UserService(new PostgreSQLDatabase());
const mongoService = new UserService(new MongoDBDatabase());

mysqlService.saveUser("John"); // Saving to MySQL: John
postgresService.saveUser("Jane"); // Saving to PostgreSQL: Jane
mongoService.saveUser("Bob"); // Saving to MongoDB: Bob
```

---

<div align="center">

## ğŸš« Anti-Patterns

</div>

### What NOT to Do âš ï¸

```
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANTI-PATTERNS (BAD PRACTICES)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   COMMON ANTI-PATTERNS                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

God Object:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: One object that does everything
âŒ Violates: Single Responsibility Principle
âœ… Solution: Break into smaller, focused classes

Example:
```

```javascript
// âŒ God Object
class Application {
  // Database operations
  saveToDatabase() {}
  queryDatabase() {}

  // UI operations
  renderUI() {}
  updateUI() {}

  // Network operations
  fetchData() {}
  sendData() {}

  // Business logic
  processOrder() {}
  calculateTotal() {}

  // Authentication
  login() {}
  logout() {}

  // And 50 more methods...
}

// âœ… Better - Separate concerns
class DatabaseService {}
class UIRenderer {}
class NetworkService {}
class OrderService {}
class AuthService {}
```

```
Spaghetti Code:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: Tangled, unstructured code
âŒ Hard to follow logic
âŒ No clear separation
âœ… Solution: Use proper structure, design patterns

Singleton Overuse:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: Using Singleton for everything
âŒ Creates global state
âŒ Hard to test
âŒ Tight coupling
âœ… Solution: Use Dependency Injection instead

Golden Hammer:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: "I have a hammer, everything is a nail"
âŒ Using same pattern/tool for everything
âŒ Forcing patterns where they don't fit
âœ… Solution: Choose right tool for the job

Premature Optimization:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: Optimizing before knowing if needed
âŒ Makes code complex
âŒ Wastes time
âœ… Solution: Optimize when profiling shows bottleneck

Copy-Paste Programming:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: Duplicating code instead of reusing
âŒ Hard to maintain
âŒ Bugs multiply
âœ… Solution: DRY (Don't Repeat Yourself)

Lava Flow:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: Dead code that nobody dares to remove
âŒ "This was important at some point..."
âŒ Clutters codebase
âœ… Solution: Remove unused code, use version control

Magic Numbers/Strings:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: Hard-coded values without explanation
```

```javascript
// âŒ Magic numbers
if (status === 3) {
  // What is 3?
  processOrder();
}

if (age > 18) {
  // Why 18?
  allowAccess();
}

// âœ… Named constants
const ORDER_STATUS_APPROVED = 3;
const MINIMUM_AGE = 18;

if (status === ORDER_STATUS_APPROVED) {
  processOrder();
}

if (age > MINIMUM_AGE) {
  allowAccess();
}
```

```
Cargo Cult Programming:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: Using code without understanding why
âŒ "It worked in tutorial, so I'll use it"
âŒ Blindly copying from Stack Overflow
âœ… Solution: Understand before using

Yo-Yo Problem:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Problem: Too many inheritance levels
âŒ Hard to trace where method is defined
âŒ Deep hierarchies
âœ… Solution: Favor composition over inheritance

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   OVER-ENGINEERING                         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

The Pattern Obsession:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
```

```javascript
// âŒ Over-engineered for simple task
class AbstractFactoryProviderFactory {
  createAbstractFactoryProvider() {
    return new AbstractFactoryProvider();
  }
}

class AbstractFactoryProvider {
  provideFactory() {
    return new ConcreteFactory();
  }
}

class ConcreteFactory {
  createProduct() {
    return new Product();
  }
}

class Product {
  doSomething() {
    return "Hello";
  }
}

// Usage - just to say "Hello"!
const factoryFactory = new AbstractFactoryProviderFactory();
const provider = factoryFactory.createAbstractFactoryProvider();
const factory = provider.provideFactory();
const product = factory.createProduct();
console.log(product.doSomething());

// âœ… Simple solution
function sayHello() {
  return "Hello";
}

console.log(sayHello());

// Remember: KISS (Keep It Simple, Stupid)
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   WHEN PATTERNS GO WRONG                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Warning Signs:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âš ï¸ More patterns than actual code
âš ï¸ 10+ layers of abstraction
âš ï¸ Simple task takes 100 lines
âš ï¸ Nobody understands the code (including you)
âš ï¸ "Enterprise" everything

Remember:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"Patterns are tools to solve problems,
not goals in themselves.

Start simple.
Add patterns when needed.
Don't force them."

- Every senior developer
```

---

<div align="center">

## ğŸ”— Pattern Combinations

</div>

### Patterns Working Together ğŸ¤

```
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATTERN COMBINATIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   COMMON COMBINATIONS                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Factory + Singleton:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Create objects using factory, but factory itself is singleton.
```

```javascript
class DatabaseFactory {
  static instance = null;

  static getInstance() {
    if (!DatabaseFactory.instance) {
      DatabaseFactory.instance = new DatabaseFactory();
    }
    return DatabaseFactory.instance;
  }

  createDatabase(type) {
    switch (type) {
      case "mysql":
        return new MySQLDatabase();
      case "postgres":
        return new PostgresDatabase();
      default:
        throw new Error("Unknown database type");
    }
  }
}

// Usage
const factory = DatabaseFactory.getInstance();
const db = factory.createDatabase("mysql");
```

```
Strategy + Factory:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Factory creates different strategy implementations.
```

```javascript
// Strategies
class CreditCardPayment {
  pay(amount) {
    console.log(`Paid ${amount} with credit card`);
  }
}

class PayPalPayment {
  pay(amount) {
    console.log(`Paid ${amount} with PayPal`);
  }
}

// Factory
class PaymentFactory {
  static createPayment(type) {
    switch (type) {
      case "card":
        return new CreditCardPayment();
      case "paypal":
        return new PayPalPayment();
      default:
        throw new Error("Unknown payment type");
    }
  }
}

// Context
class ShoppingCart {
  constructor(paymentType) {
    this.payment = PaymentFactory.createPayment(paymentType);
  }

  checkout(amount) {
    this.payment.pay(amount);
  }
}

// Usage
const cart = new ShoppingCart("paypal");
cart.checkout(100);
```

```
Observer + Singleton:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Event bus/manager as singleton, multiple observers.
```

```javascript
class EventBus {
  static instance = null;

  constructor() {
    if (EventBus.instance) {
      return EventBus.instance;
    }
    this.events = {};
    EventBus.instance = this;
  }

  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }

  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach((callback) => callback(data));
    }
  }
}

// Usage anywhere in app
const bus = new EventBus();
bus.on("userLogin", (user) => console.log("User logged in:", user));

// Somewhere else in app
const bus2 = new EventBus(); // Same instance!
bus2.emit("userLogin", { name: "John" });
```

```
Decorator + Strategy:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Decorate strategies with additional behavior.
```

```javascript
// Base strategy
class BasicEncryption {
  encrypt(data) {
    return btoa(data); // Base64
  }
}

// Decorators
class CompressionDecorator {
  constructor(encryptor) {
    this.encryptor = encryptor;
  }

  encrypt(data) {
    console.log("Compressing...");
    const compressed = data; // Simplified
    return this.encryptor.encrypt(compressed);
  }
}

class LoggingDecorator {
  constructor(encryptor) {
    this.encryptor = encryptor;
  }

  encrypt(data) {
    console.log("Logging encryption...");
    return this.encryptor.encrypt(data);
  }
}

// Usage - Stack decorators
let encryptor = new BasicEncryption();
encryptor = new CompressionDecorator(encryptor);
encryptor = new LoggingDecorator(encryptor);

console.log(encryptor.encrypt("secret"));
// Logging encryption...
// Compressing...
// c2VjcmV0
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   MVC PATTERN (COMBINATION)                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Model-View-Controller:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Combines multiple patterns:
â€¢ Observer (View observes Model)
â€¢ Strategy (Controller strategies)
â€¢ Composite (View hierarchy)
```

```javascript
// Model (Observable)
class UserModel {
  constructor() {
    this.users = [];
    this.observers = [];
  }

  addUser(user) {
    this.users.push(user);
    this.notify();
  }

  getUsers() {
    return this.users;
  }

  subscribe(observer) {
    this.observers.push(observer);
  }

  notify() {
    this.observers.forEach((observer) => observer.update(this));
  }
}

// View (Observer)
class UserView {
  constructor(model) {
    this.model = model;
    this.model.subscribe(this);
  }

  update(model) {
    console.log("View updated with users:", model.getUsers());
  }

  render() {
    const users = this.model.getUsers();
    return users.map((u) => `<div>${u.name}</div>`).join("");
  }
}

// Controller
class UserController {
  constructor(model) {
    this.model = model;
  }

  addUser(name, email) {
    this.model.addUser({ name, email });
  }
}

// Usage
const model = new UserModel();
const view = new UserView(model);
const controller = new UserController(model);

controller.addUser("John", "john@example.com");
// View updated with users: [{ name: 'John', email: 'john@example.com' }]

console.log(view.render());
// <div>John</div>
```

---

<div align="center">

## ğŸ’¡ Best Practices

</div>

### Master Design Patterns ğŸ“

```
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DESIGN PATTERN BEST PRACTICES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   LEARNING PATTERNS                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Start Simple:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. Learn one pattern at a time
2. Understand the problem it solves
3. Implement it yourself
4. Use it in real project
5. Move to next pattern

Don't Memorize - Understand:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Memorizing code examples
âœ… Understanding when and why to use

Practice Order:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Beginner:
1. Singleton (easy to understand)
2. Factory Method (very practical)
3. Observer (event-driven apps)
4. Strategy (algorithm switching)
5. Decorator (add features)

Intermediate:
6. Builder (complex objects)
7. Adapter (integrate systems)
8. Facade (simplify interfaces)
9. Template Method (algorithms)
10. State (state machines)

Advanced:
11. Abstract Factory
12. Proxy
13. Composite
14. Chain of Responsibility
15. Command

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   WHEN TO USE PATTERNS                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Decision Tree:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

Need to create objects?
â”œâ”€ Complex creation logic? â†’ Builder
â”œâ”€ Don't know exact type? â†’ Factory
â”œâ”€ Only one instance? â†’ Singleton
â””â”€ Copy existing? â†’ Prototype

Need to structure objects?
â”œâ”€ Incompatible interfaces? â†’ Adapter
â”œâ”€ Add features dynamically? â†’ Decorator
â”œâ”€ Simplify complex system? â†’ Facade
â””â”€ Control access? â†’ Proxy

Need objects to communicate?
â”œâ”€ Notify multiple objects? â†’ Observer
â”œâ”€ Switch algorithms? â†’ Strategy
â”œâ”€ Behavior based on state? â†’ State
â”œâ”€ Pass request along chain? â†’ Chain of Responsibility
â””â”€ Encapsulate requests? â†’ Command

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   PRACTICAL GUIDELINES                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Don't Force Patterns:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Let them emerge naturally
âœ… Refactor into patterns when needed
âŒ Don't start with patterns

2. Start Simple, Refactor Later:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
"Make it work, make it right, make it fast"
- Kent Beck

Step 1: Write simple code that works
Step 2: Identify problems/smells
Step 3: Apply appropriate pattern
Step 4: Optimize if needed

3. Know When NOT to Use:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Simple scripts/prototypes
âŒ Quick one-off tasks
âŒ Team doesn't understand patterns
âŒ Adds unnecessary complexity

4. Communicate with Team:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Use pattern names (common vocabulary)
âœ… Document why pattern was chosen
âœ… Ensure team understands
âœ… Code reviews discuss patterns

5. Test Your Patterns:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Patterns should make testing easier
âœ… Mock dependencies
âœ… Test each component separately
âœ… Integration tests

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   CODE QUALITY CHECKLIST                   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Before Applying Pattern:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â˜ Do I understand the problem?
â˜ Is there actually a problem?
â˜ Is this the right pattern?
â˜ Does it simplify or complicate?
â˜ Will the team understand it?
â˜ Can I test it easily?
â˜ Is it maintainable?
â˜ Am I over-engineering?

After Applying Pattern:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
â˜ Code is easier to understand?
â˜ Easier to extend?
â˜ Easier to test?
â˜ Less coupled?
â˜ Follows SOLID principles?
â˜ Team can maintain it?

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   COMMON MISTAKES                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Pattern for Pattern's Sake:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ "Let's use Strategy pattern because it's cool"
âœ… "We need to switch algorithms, Strategy fits"

2. Premature Patterning:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Start with complex pattern structure
âœ… Start simple, refactor into pattern when needed

3. Wrong Pattern Choice:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ Force pattern that doesn't fit
âœ… Choose pattern that solves your problem

4. Over-Engineering:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ 10 patterns for simple app
âœ… Patterns only where they add value

5. Ignoring Context:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âŒ "This pattern worked in Java, use in JavaScript"
âœ… Adapt pattern to language/framework

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   LEARNING RESOURCES                       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Books:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“š "Design Patterns" - Gang of Four (Original)
ğŸ“š "Head First Design Patterns" - Freeman (Best for beginners)
ğŸ“š "Refactoring" - Martin Fowler
ğŸ“š "Clean Code" - Robert Martin
ğŸ“š "Design Patterns in JavaScript" - Addy Osmani (Free online)

Websites:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”— refactoring.guru (Best visual explanations)
ğŸ”— sourcemaking.com (Anti-patterns too)
ğŸ”— patterns.dev (Modern JavaScript patterns)
ğŸ”— github.com/kamranahmedse/design-patterns-for-humans

Practice:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ’ª Implement each pattern yourself
ğŸ’ª Use in real projects
ğŸ’ª Code reviews
ğŸ’ª Teach others (best way to learn)
ğŸ’ª Refactor existing code

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   FINAL WISDOM                             â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Remember:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

"Patterns are tools in your toolbox.
A good carpenter knows when to use a hammer,
when to use a screwdriver,
and when to put tools away and solve problem differently.

Start simple.
Add patterns when they solve real problems.
Refactor fearlessly.
Keep learning.

The goal is not to use all patterns.
The goal is to write maintainable code."

Key Takeaways:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âœ… Patterns solve common problems
âœ… Not all problems need patterns
âœ… Understand SOLID principles first
âœ… Learn by doing, not reading
âœ… Refactor into patterns, don't start with them
âœ… Simple is better than complex
âœ… Patterns are means, not ends
âœ… Team understanding > individual genius

Now go write clean, maintainable code! ğŸš€
```

---

<div align="center">

## ğŸ“Š Quick Reference

</div>

### Pattern Cheat Sheet ğŸ“

| Pattern                     | Category   | Problem                   | Solution               | Use When                 |
| --------------------------- | ---------- | ------------------------- | ---------------------- | ------------------------ |
| **Singleton**               | Creational | Need one instance         | Single global instance | Database, config, logger |
| **Factory**                 | Creational | Don't know exact type     | Create via factory     | Object creation varies   |
| **Builder**                 | Creational | Complex construction      | Build step-by-step     | Many parameters          |
| **Prototype**               | Creational | Expensive creation        | Clone existing         | Performance critical     |
| **Adapter**                 | Structural | Incompatible interfaces   | Convert interface      | Legacy integration       |
| **Decorator**               | Structural | Add features dynamically  | Wrap with features     | Flexible extensions      |
| **Facade**                  | Structural | Complex subsystem         | Simple interface       | Simplify complexity      |
| **Proxy**                   | Structural | Control access            | Surrogate object       | Lazy load, security      |
| **Observer**                | Behavioral | Notify multiple objects   | Subscribe/notify       | Events, data binding     |
| **Strategy**                | Behavioral | Switch algorithms         | Encapsulate algorithm  | Multiple algorithms      |
| **Command**                 | Behavioral | Encapsulate request       | Request as object      | Undo/redo, queues        |
| **State**                   | Behavioral | Behavior changes by state | State objects          | State machines           |
| **Template Method**         | Behavioral | Common algorithm          | Define skeleton        | Framework design         |
| **Chain of Responsibility** | Behavioral | Multiple handlers         | Chain handlers         | Middleware, events       |

### SOLID Quick Reference

| Principle                     | Means                                       | Example                      |
| ----------------------------- | ------------------------------------------- | ---------------------------- |
| **S** - Single Responsibility | One reason to change                        | User class vs UserRepository |
| **O** - Open/Closed           | Open for extension, closed for modification | Shape hierarchy              |
| **L** - Liskov Substitution   | Subclass can replace superclass             | Proper inheritance           |
| **I** - Interface Segregation | Many specific interfaces                    | Worker interfaces            |
| **D** - Dependency Inversion  | Depend on abstractions                      | Inject dependencies          |

---

<div align="center">

**Built with ğŸ›ï¸ by MrDib, for better software design**

_Remember: "Patterns are solutions, not goals!"_ âœ¨

**Happy Coding!** ğŸš€

</div>

---

## ğŸ”— Related Guides

- [System Design](./System-Design.md)
- [Best Practices](./Best-Practices.md)
- [Clean Code](../Development/Clean-Code.md)
- [Software Architecture](./Microservices.md)

---

## ğŸ“– Further Reading

### Recommended Books:

- ğŸ“š **Head First Design Patterns** - Best for beginners
- ğŸ“š **Design Patterns (GoF)** - The classic
- ğŸ“š **Refactoring** by Martin Fowler
- ğŸ“š **Clean Code** by Robert Martin

### Online Resources:

- ğŸ”— [Refactoring.Guru](https://refactoring.guru/design-patterns) - Best visual guide
- ğŸ”— [SourceMaking](https://sourcemaking.com/design_patterns)
- ğŸ”— [Patterns.dev](https://patterns.dev) - Modern JavaScript patterns
- ğŸ”— [GitHub: Design Patterns for Humans](https://github.com/kamranahmedse/design-patterns-for-humans)

---
